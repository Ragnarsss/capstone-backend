import { describe, it, expect, vi, beforeEach } from 'vitest';
import { AuthMiddleware } from '../presentation/auth-middleware';
import type { AuthService } from '../application/auth.service';
import type { FastifyRequest, FastifyReply } from 'fastify';

describe('AuthMiddleware', () => {
    let middleware: AuthMiddleware;
    let mockAuthService: AuthService;
    let mockRequest: FastifyRequest;
    let mockReply: FastifyReply;

    beforeEach(() => {
        mockAuthService = {
            authenticateFromHeader: vi.fn(),
        } as any;

        middleware = new AuthMiddleware(mockAuthService);

        mockRequest = {
            headers: {
                authorization: 'Bearer valid-jwt-token',
            },
        } as any;

        mockReply = {
            code: vi.fn().mockReturnThis(),
            send: vi.fn(),
        } as any;
    });

    describe('authenticate() - obligatorio', () => {
        it('debería adjuntar usuario a request si el token es válido', async () => {
            const mockUser = {
                userId: 12345n,
                email: 'test@example.com',
                name: 'Test User',
            };

            vi.mocked(mockAuthService.authenticateFromHeader).mockResolvedValue(mockUser);

            await middleware.authenticate(mockRequest, mockReply);

            expect(mockRequest.user).toEqual(mockUser);
            expect(mockAuthService.authenticateFromHeader).toHaveBeenCalledWith('Bearer valid-jwt-token');
        });

        it('debería lanzar AuthenticationError si no hay header Authorization', async () => {
            mockRequest.headers = {};

            vi.mocked(mockAuthService.authenticateFromHeader).mockRejectedValue(
                Object.assign(new Error('No token provided'), { code: 'NO_TOKEN' })
            );

            const handler = middleware.authenticate();
            await expect(handler(mockRequest, mockReply)).rejects.toThrow('No token provided');
            expect(mockRequest.user).toBeUndefined();
        });

        it('debería lanzar AuthenticationError si el token es inválido', async () => {
            vi.mocked(mockAuthService.authenticateFromHeader).mockRejectedValue(
                Object.assign(new Error('Invalid token'), { code: 'INVALID_TOKEN' })
            );

            const handler = middleware.authenticate();
            await expect(handler(mockRequest, mockReply)).rejects.toThrow('Invalid token');
            expect(mockRequest.user).toBeUndefined();
        });

        it('debería lanzar AuthenticationError si el token está expirado', async () => {
            vi.mocked(mockAuthService.authenticateFromHeader).mockRejectedValue(
                Object.assign(new Error('Token expired'), { code: 'TOKEN_EXPIRED' })
            );

            const handler = middleware.authenticate();
            await expect(handler(mockRequest, mockReply)).rejects.toThrow('Token expired');
            expect(mockRequest.user).toBeUndefined();
        });

        it('debería propagar errores genéricos del servicio', async () => {
            vi.mocked(mockAuthService.authenticateFromHeader).mockRejectedValue(
                new Error('Database connection failed')
            );

            const handler = middleware.authenticate();
            await expect(handler(mockRequest, mockReply)).rejects.toThrow('Database connection failed');
        });
    });

    describe('optionalAuthenticate() - opcional', () => {
        it('debería adjuntar usuario si el token es válido', async () => {
            const mockUser = {
                userId: 67890n,
                email: 'optional@example.com',
                name: 'Optional User',
            };

            vi.mocked(mockAuthService.authenticateFromHeader).mockResolvedValue(mockUser);

            await middleware.optionalAuthenticate(mockRequest, mockReply);

            expect(mockRequest.user).toEqual(mockUser);
            expect(mockAuthService.authenticateFromHeader).toHaveBeenCalledWith('Bearer valid-jwt-token');
        });

        it('NO debería lanzar error si no hay header Authorization', async () => {
            mockRequest.headers = {};

            vi.mocked(mockAuthService.authenticateFromHeader).mockRejectedValue(
                Object.assign(new Error('No token provided'), { code: 'NO_TOKEN' })
            );

            await middleware.optionalAuthenticate(mockRequest, mockReply);

            expect(mockRequest.user).toBeUndefined();
            // No debe lanzar error
        });

        it('NO debería lanzar error si el token es inválido', async () => {
            vi.mocked(mockAuthService.authenticateFromHeader).mockRejectedValue(
                Object.assign(new Error('Invalid token'), { code: 'INVALID_TOKEN' })
            );

            await middleware.optionalAuthenticate(mockRequest, mockReply);

            expect(mockRequest.user).toBeUndefined();
            // No debe lanzar error
        });

        it('NO debería lanzar error si el token está expirado', async () => {
            vi.mocked(mockAuthService.authenticateFromHeader).mockRejectedValue(
                Object.assign(new Error('Token expired'), { code: 'TOKEN_EXPIRED' })
            );

            await middleware.optionalAuthenticate(mockRequest, mockReply);

            expect(mockRequest.user).toBeUndefined();
            // No debe lanzar error
        });

        it('debería adjuntar usuario si el token es válido (caso: usuario autenticado opcional)', async () => {
            const mockUser = {
                userId: 11111n,
                email: 'auth-optional@example.com',
                name: 'Auth Optional',
            };

            vi.mocked(mockAuthService.authenticateFromHeader).mockResolvedValue(mockUser);

            await middleware.optionalAuthenticate(mockRequest, mockReply);

            expect(mockRequest.user).toEqual(mockUser);
        });
    });
});
